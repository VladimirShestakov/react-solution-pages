# Управление зависимостями

С помощью React-Solution в главном файле `src/index.tsx` создаётся DI контейнер (Dependency Injection Container). В контейнер внедряются все необходимые решения - сервисы, модули, фичи, компоненты, классы, функции, опции... По сути все решения - это объекты. Хотя внедряются не сами объекты, а инструкции как их создавать и какие у них зависимости. Такие инструкции называются инъекциями. Одной из главных инъекций является сервис рендера на React. 

```tsx
function createSolutions(envPatch: Patch<Env> = {}): Container {
    return new Container()  
      .set(envClient(envPatch))  
      .set(configs)  
      .set(renderService)  // <-- Инъекция сервиса рендера на React
      .set(routerService)  
      .set(modalsService)  
      .set(httpClient)  
      .set(i18nService)  
      .set(logService)  
      .set(dumpService)  
      .set({  
        token: RENDER_COMPONENT,  
        depends: { router: ROUTER_SERVICE },  
        factory: ({ router }) => (  
          <RouterProvider router={router}>  
            <App />      
          </RouterProvider>    
        ),  
      });
}
```

Инъекция `renderService` подготовлена в исходниках фреймворка, чтобы упростить её подключение. Тоже самое касается других инъекций. Для отдельного объявления инъекции используются вспомогательные функции `injectClass()`, `injectFactory()` или `injectValue()` - они нужны только для удобной типизации свойств инъекции.

```ts
const renderService = injectClass({  
  token: RENDER_SERVICE,  
  constructor: RenderService, // Класс сервиса (конструктор) 
  depends: {  
    env: ENV,  
    container: CONTAINER,  
    logger: LOG_SERVICE,  
    config: optionalToken(RENDER_CFG),
    dump: optionalToken(DUMP_SERVICE),    
    children: optionalToken(RENDER_COMPONENT),  
  },  
});
```

Инъекция содержит токен для идентификации (`token`) , перечисление зависимостей (`depends`) и функцию создания объекта (`factory` или `constructor`). В функцию `factory` или в `constructor` класса будут передаваться объекты, чьи токены перечислены в `depends`. 

`RenderService` представляет собой простой класс необременённый архитектурными особенностями DI, а все зависимости ожидаются в первом аргументе конструктора. Первый аргумент конструктора отмечен ключевым словом `protected`, чтобы автоматически превратился в поле класса.

```ts
class RenderService {  
  constructor(protected depends: {
      env: Env;  
      container: Container;  
      logger: LogInterface;
      config?: Patch<RenderConfig>;
      dump?: DumpService;          
      children?: ReactNode;
  }) {
    //...
  }
}
```

У `RenderService` много зависимостей, и для корректной работы все зависимости нужно будет внедрить в контейнер. Некоторые зависимости опциональные. Например, можно не внедрять настройки, тогда будут применены настройки по умолчанию. Опциональность зависимости учитывается в классе `RenderService`, а через опциональный токен `optionalToken(RENDER_CFG)` в инъекции об этом сообщается контейнеру.

Контейнер наполняется всеми инъекциями в главном файле `src/index.tsx`. Но инъекция не выполняется сразу при добавлении в контейнер. Исполнение инъекции происходит только при выборке объекта из контейнера по соответствующему токену методом `async get(token)`. Контейнер найдёт по токену инъекцию и, если она ещё не выполнялась, то подготовит все зависимости (выберет их тем же методом `get`), выполнит функцию или конструктор инъекции и вернет результат. Если инъекция уже исполнялась, то будет возвращен ранее полученный результат. Таким образом, выбираемые объекты будут создаваться в единственном экземпляре при первом обращении к ним.

В файле `index.tsx` после создания и наполнения контейнера нужно запустить основную логику приложения. Из контейнера выбирается сервис рендера и запускается его работа. В свою очередь уже контейнером будут созданы другие объекты (сервис логирования и дампа, react элемент для рендера и другие объекты), чтобы передать их в конструктор сервиса рендера. По ходу выполнения программы из контейнера будут браться и другие объекты.

Для выборки объекта из контейнера нужно указать только токен. Не нужно заботиться о дополнительных параметрах и инициализациях объекта. Просто берем объект из контейнера и используем его.

```ts 
const render = await solutions.get(RENDER_SERVICE);  // выбор сервиса из контейрера solutions
render.start();
```

Сервис рендера выбирается по токену `RENDER_SERVICE` , далее вызывается метод `start()` для запуска рендера в браузере. В метод ничего не передаётся для рендера, хотя можно было бы ожидать передачи react элемента. Дело в том, что корневой react элемент часто оборачивается провайдерами для установки в контекст роутера, хранилища и прочего, что по сути является зависимостью для react элемента. А для управления зависимостями имеется DI контейнер. Поэтому корневой react элемент определяется инъекцией в контейнер и автоматически получает все необходимые зависимости. 

```tsx
.set({  
  token: RENDER_COMPONENT,  
  depends: { router: ROUTER_SERVICE },  
  factory: ({ router }) => (  
    <RouterProvider router={router}>  
      <App />    
    </RouterProvider>
  ),  
})
```

Всё что нужно элементу указывается в `depends`, и будет передано в функцию `factory`. Функция `factory` вернёт подготовленный react элемент. Сервис рендера получит react элемент для рендера по токену `RENDER_COMPONENT` так как у сервиса рендера есть зависимость `children` с таким же токеном.
#### _Итог_

*Внедрение зависимостей* (DI) необходимо для слабой связанности между различными частями приложения и для легкой адаптации приложения под разные условия. Внедрение зависимостей обеспечивает *инверсию управления*, когда программный объект самостоятельно не импортирует и не выбирает себе зависимые объекты, а получает их от инициатора действия. Это касается даже внешних библиотек - вместо того чтобы их импортировать, возможно, правильней будет получать их от DI, абстрагируясь от конкретной реализации.

За счёт слабой связанности программные объекты (решения) можно разрабатывать независимо друг от друга в разных репозиториях разными командами и легко переключаться на разные реализации, адаптируя программу под разные условия. Замена инъекции в контейнере приводит к замене используемого объекта во всём приложении. И не нужно будет по всему исходному коду менять логику передачи зависимостей. Например, сервис кэширования в оперативной памяти легко подменить на сопоставимый сервис кэширования в файлы. Или применять разные реализации сервисов на клиенте и на бэкенде. Возможность подмены через DI активно применяется для функционального тестирования с использованием моковых версий сервисов, например, чтобы не выполнять реальные запросы к АПИ в автоматических тестах. 

## Токен

Токен используется для идентификации зависимостей и мог бы быть уникальной строкой или числом. Но кроме идентификации нужен контроль типов, чтобы в инъекциях можно было указать идентификатор только на сопоставимый тип объекта, чтобы гарантировать корректность самой инъекции. Поэтому к уникальному значению привязывается тип зависимости. Связка идентификатора с полезной нагрузкой (типом) называется токеном. Для создания токена используется утилита:

```ts
function newToken<Type>(name: string): Token<Type>
```

Необходимо обязательно указать связываемый тип данных и уникальную строку в качестве названия токена. Для обеспечения уникальности предлагается использовать формат URI, например `"my-project/my-service"`. Новые токены желательно создавать в отдельных файлах, чтобы можно было импортировать их отдельно от реализации решения.

```ts
// Токен на тип MyService (класс или интерфейс сервиса)
export const MY = newToken<MyService>('my-project/my-service')
// Токен на тип MyServiceConfig (настройки сервиса)
export const MY_CONFIG = newToken<MyServiceConfig>('my-project/my-service/config')
```

Константа `MY` будет объектом с типом `Token<MyService`. Токен - это не строка, а объект, что позволяет в токене хранить дополнительную полезную информацию, в частности атрибут опциональности.  
#### _Опциональный токен_

Опциональный токен создаётся через декорирование обычного токена утилитой:

```ts
function optionalToken<Type>(token: Token<Type>): TokenDecorator<Type | undefined>
```

Будет создан новый токен, внутри которого будет ссылка на оригинальный токен. Уникальное значение токена будет браться из оригинального токена, но новый токен-декоратор будет подставлять свой предопределённый атрибут опциональности, при этом оригинальный токен не меняется. Заранее создавать опциональные токены не нужно, достаточно декорировать оригинальные токены на месте применения. 

```ts
const MY_OPTIONAL = optionalToken(MY) // :TokenDecorator<MyService | undefined>

console.log(MY_OPTIONAL.is('optional')) // true
console.log(MY_OPTIONAL.key === MY.key) // true
```

Опциональный токен `MY_OPTIONAL` связан с типом `MyService | undefined` и может применяться для указания опциональных зависимостей. Если зависимость опциональная, то подойдет и оригинальный токен, но если в контейнере не будет соответствующей инъекции, то контейнер выкинет исключение, так как оригинальный токен не допускает отсутствия значения. С опциональным токеном ошибок не будет и в зависимость подставится `undefined`. И за счёт строгой типизации инъекции опциональный токен не получится ошибочно подставить для обязательной зависимости. 
#### _Итог_

Токены создаются под новые решения, чтобы решения можно было внедрить в DI контейнер и использовать как зависимость в других решениях. Токены также создаются под составные части новых решений, если предполагается получать их как зависимость. Например, токен создаётся на настройки сервиса.

Новый токен не нужно создавать, если планируется реализация аналога некого решения и в аналоге полностью реализуется программный интерфейс оригинального решения без добавления новых методов. Решение-аналог будет внедряться в контейнер по токену оригинального решения.

Так как токены импортируются напрямую в других решениях, то их необходимо описывать в отдельных файлах, отдельно от исходников самого решения. Иначе в сборку решения-аналога попадет исходник оригинального решения, что бессмысленно раздует сборку. 

Токены связаны с типом решения и это позволяется выводить типы по месту применения токена. Например, контейнер заранее не знает, какие инъекции в него будут добавлены, у контейнера нет агрегированного типа про все инъекции. Только за счет самого токена методы set и get будут выводить тип решения. Токеном обеспечивается слабая связанность в системе типов.

## Инъекция

В контейнер можно внедрить инъекцию с функцией, классом или уже созданным объектом (значением). Удобней заранее определить инъекцию, чтобы не расписывать её при внедрении в контейнер. Для этого имеются вспомогательные функции для типизации инъекции.
#### Инъекция функции

Инъекция функции универсальная, так как позволяет реализовать любую логику создания и инициализации объекта или просто вернуть уже готовый. Кроме того, функция может быть асинхронной. Через функцию несложно внедрить сторонние решения, например react-router или redux.

```ts
function injectFactory<Type, Deps>(inject: {
  token: Token<Type>
  depends: Deps
  factory: (depends: TypesFromTokens<Deps>) => Type | Promise<Type>
}): InjectFactory<Type, Deps>
```

Функция указывается в свойстве `factory` (от англ. фабрика).  Необходимые зависимости указываются свойством `depends` в виде объекта, все свойства которого должны содержать токены на соответствующие зависимости. Все зависимости будут переданы в первый аргумент функции `factory: (depends) => {}` в виде объекта с теми же названиями свойств как и в описании инъекции. Функция `factory` должна вернуть объект, тип которого сопоставим с токеном инъекции.  За счёт применения typescript дженерика тип результата функции сопоставляется с токеном, а тип аргумента функции с токенами в depends. 

Пример инъекции вымышленного стороннего решения `SomeLibrary` с особым способом инициализации. 

```ts
const SOME = newToken<SomeLibrary>('my-project/some');

const someInjection = injectFactory({
  token: SOME,
  depends: { logger: LOGS },
  factory: async ({ logger }) => {
    // Пример стороннего решения со специфической логикой инициализации
    const some = new SomeLibrary().setLogger(logger);
	await some.setSomeOption('option');		
	return some;
  }
})

```
#### Инъекция класса

Для инъекции класса нужно учитывать одно условие - все зависимости передаются в первый аргумент конструктора в виде mapped-объекта. То есть так же, как передаются в функцию `factory`. При самостоятельной реализации классов это условие несложно соблюдать и тогда в инъекцию можно передать сам класс (фактически передаётся функция-констурктор)

```ts
function injectClass<Type, Deps>(inject: {
  token: Token<Type>
  depends: Deps;
  constructor: new (depends: TypesFromTokens<Deps>) => Type
}): InjectClass<Type, Deps>
```

Большинство решений в React-Solution реализуется через классы. Для примера можно реализовать свой класс `First` с некоторыми зависимостями, необходимыми в логике класса.

```ts
class First {
  contructor(protected depends: {
    logger: ILogger,
    config: Patch<FirstConfig>
  }) {
    //...
  }
  exmaple() {
     this.depends.logger.error('Метод ещё в разработке');
  }
}
```

Создать токен на тип `First` и настройки `Patch<FirstConfig>`

```ts
export FIRST = newToken<First>('my-project/first')
export FIRST_CFG = newToken<Patch<FirstConfig>>('my-project/first/config')
```

Подготовить инъекцию:

```ts
export firstInjection = injectClass({
  token: FIRST,
  depends: { logger: LOGS, config: FIRST_CFG },
  constructor: First
})
```

И внедрить инъекцию в контейнер в главном файле:

```ts
function createSolutions(envPatch: Patch<Env> = {}): Container {
    return new Container() 
      //....
      .set(firstInjection)
}
```
#### Инъекция значения

В некоторых случаях нужно просто внедрить значение. Значение, которое заранее известно и нет необходимости его создавать во время выполнения. Это могут быть переменные окружения, настройки, словари локализации, данные-заглушки и прочее. Тогда инъекция может содержать само значение и не потребуется описывать зависисомтсей - только токен и значение. 

```ts
function injectValue<Type>(inject: { token: Token<Type>, value: Type }): InjectValue<Type>
```

Например, в виде значения можно внедрить переменные окружения 

```ts
const envInjection = injectValue({  
  token: ENV,  
  value: {  
    MODE: process.env.NODE_ENV || 'development',  
    PROD: !process.env.NODE_ENV || process.env.NODE_ENV === 'production', 
  },  
})
```

[← Команды npm для SPA и SSR](2.%20Команды%20npm%20для%20SPA%20и%20SSR.md)


