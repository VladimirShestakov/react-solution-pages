## Инъекция

В контейнер можно внедрить инъекцию с функцией, классом или уже созданным значением (объектом). Удобней заранее определить инъекцию, чтобы не расписывать её при внедрении в контейнер. Для этого имеются вспомогательные функции для типизации инъекции.
#### Инъекция функции

Инъекция функции универсальная, так как позволяет реализовать любую логику создания и инициализации объекта или просто вернуть уже готовый. Кроме того, функция может быть асинхронной. Через функцию несложно внедрить сторонние решения, например react-router или redux.

```ts
function injectFactory<Type, Deps>(inject: {
  token: Token<Type>
  depends: Deps
  factory: (depends: TypesFromTokens<Deps>) => Type | Promise<Type>
}): InjectFactory<Type, Deps>
```

Функция указывается в свойстве `factory` (от англ. фабрика).  Необходимые зависимости указываются свойством `depends` в виде объекта, все свойства которого должны содержать токены на соответствующие зависимости. Все зависимости будут передаваться в первый аргумент функции `factory: (depends) => {}` в виде объекта с теми же названиями свойств как и в описании инъекции. Функция `factory` должна вернуть объект, тип которого сопоставим с токеном инъекции.  За счёт применения typescript дженерика тип результата функции сопоставляется с токеном, а тип аргумента функции с токенами в depends. 

Пример инъекции вымышленного стороннего решения `SomeLibrary` с особым способом инициализации. 

```ts
const SOME = newToken<SomeLibrary>('my-project/some');

const someInjection = injectFactory({
  token: SOME,
  depends: { logger: LOGS },
  factory: async ({ logger }) => {
    // Пример стороннего решения со специфической логикой инициализации
    const some = new SomeLibrary().setLogger(logger);
	await some.setSomeOption('option');		
	return some;
  }
})

```

При создании инъекции не нужно думать, от куда возьмутся указанные зависимости, например сервис логирования. В инъекции только указывается, что нужно для функции `factory`, что вернёт функция `factory`, и указывается сама функция `factory`. Созданную инъекцию остаётся внедрить в контейнер в главном файле:

```ts
function createSolutions(envPatch: Patch<Env> = {}): Container {
    return new Container() 
      //....
      .set(someInjection) // <--- внедрение
}
```

Инициализированное стороннее решение `SomeLibrary` теперь доступно из любого места в программном коде выборкой вручную из контейнера по токену SOME, либо автоматически в качестве зависимости.
#### Инъекция класса

Для инъекции класса нужно учитывать одно условие - все зависимости передаются в первый аргумент конструктора в виде mapped-объекта - так же, как передаются в функцию `factory`. При самостоятельной реализации классов это условие несложно соблюдать и тогда в инъекцию можно передать сам класс (фактически передаётся функция-констурктор)

```ts
function injectClass<Type, Deps>(inject: {
  token: Token<Type>
  depends: Deps;
  constructor: new (depends: TypesFromTokens<Deps>) => Type
}): InjectClass<Type, Deps>
```

Большинство решений в React-Solution реализуются через классы. Для примера можно реализовать свой класс `First` с некоторыми зависимостями, необходимыми в логике класса.

```ts
class First {
  contructor(protected depends: {
    logger: ILogger,
    config: Patch<FirstConfig>
  }) {
    //...
  }
  
  exmaple() {
    this.depends.logger.error('Метод ещё в разработке');
  }
}
```

Создать токен на тип `First` и токен на настройки `Patch<FirstConfig>`

```ts
export FIRST = newToken<First>('my-project/first')
export FIRST_CFG = newToken<Patch<FirstConfig>>('my-project/first/config')
```

Подготовить инъекцию:

```ts
export firstInjection = injectClass({
  token: FIRST,
  depends: { logger: LOGS, config: FIRST_CFG },
  constructor: First
})
```

И внедрить инъекцию в контейнер в главном файле:

```ts
function createSolutions(envPatch: Patch<Env> = {}): Container {
    return new Container() 
      //....
      .set(firstInjection)
}
```

Экземпляр класса First теперь доступен из любого места в программном коде выборкой вручную из контейнера, либо автоматически в качестве зависимости.
#### Инъекция значения

В некоторых случаях нужно просто внедрить значение. Тогда инъекция может содержать только значение и токен без зависимостей.

```ts
function injectValue<Type>(inject: { token: Token<Type>, value: Type }): InjectValue<Type>
```

 Внедрять в виде значения допустимо всё, что можно создать заранее, не будет изменяться и не нуждается в зависимостях. Например, в качестве значением могут быть переменные окружения, настройки сервисов, словари для локализации, данные-заглушки, глобальные константы и прочее. В примере ниже описана инъекция двух переменных окружения.

```ts
const envInjection = injectValue({  
  token: ENV,  
  value: {  
    MODE: process.env.NODE_ENV || 'development',  
    PROD: !process.env.NODE_ENV || process.env.NODE_ENV === 'production', 
  },  
})
```
### Инъекция изменений

Инъекция изменений позволяет расширить уже внедренную инъекцию. По умолчанию, если в контейнер внедрить инъекцию с токеном, по которому уже было внедрение, то текущая инъекция просто заменится на новую - никакого расширения не произойдет. Но, если в инъекции указать свойство `merge: true`, то контейнер будет учитывать новую инъекцию не игнорируя текущую. Контейнер будет выполнять все инъекции и объединять их результаты в одно общее значение используя алгоритм глубокого слияния объектов. Объединяются не инъекции, а их результаты! Естественно, слияние не подходит для всех типов. Например, не стоит таким образом расширять экземпляры сервисов. Инъекция изменений отлично подходит для расширения уже внедренных настроек или переменных окружений - то есть значений, тип которых предусматривает расширение свойств.

```ts
const envInjection = injectValue({  
  token: ENV,  
  value: {  
    NEW_VALUE: 'new environment' 
  },
  merge: true  // <-- выполнять слияние с существующей инъекцией
})
```

Внедрение изменений можно применять для расширения сервисов через расширение их настроек или используемых ресурсов.  Например, у сервиса мультиязычности есть зависимость на словарь локализации. И этот словарь можно расширять через инъекцию изменений! Каждая фича в приложении может определять свой маленький словарик и внедрять его в контейнер под токеном `I18N_DICTIONARY`. Сам словарь не обязан быть простым объектом, он может содержать и функции - они не сломаются из-за объединения. 

```ts
export const injectTranslations = injectValue({  
  token: I18N_DICTIONARY,  
  value: {  
    'en-EN': { catalog: () => import('./en.json') },  
    'ru-RU': { catalog: () => import('./ru.json') },  
  },  
  merge: true,  
});
```

В контейнер можно внедрить любое количество инъекций с одинаковым токеном. Результат инъекции со свойством `merge: true` будет объединяться с результатом предыдущей инъекцией. А инъекция с `merge: false` (или не определено), будет замещать все предыдущие инъекции с тем же токеном.

← [Инъекция](dependency_management/injection.md) | [Контейнер](dependency_management/di_container.md) →
