## Внедрение зависимостей

С помощью React-Solution в главном файле `src/index.tsx` создаётся DI контейнер (Dependency Injection Container). В контейнер внедряются все необходимые решения - сервисы, модули, фичи, компоненты, классы, функции, опции... По сути все решения - это объекты. Хотя внедряются не сами объекты, а инструкции как их создавать и какие у них зависимости. Такие инструкции называются инъекциями. Одной из главных инъекций является сервис рендера на React. 

```tsx
function createSolutions(envPatch: Patch<Env> = {}): Container {
    return new Container()  
      .set(envClient(envPatch))  
      .set(configs)  
      .set(renderService)  // <-- Инъекция сервиса рендера на React
      .set(routerService)  
      .set(modalsService)  
      .set(httpClient)  
      .set(i18nService)  
      .set(logService)  
      .set(dumpService)  
      .set({  
        token: RENDER_COMPONENT,  
        depends: { router: ROUTER_SERVICE },  
        factory: ({ router }) => (  
          <RouterProvider router={router}>  
            <App />      
          </RouterProvider>    
        ),  
      });
}
```

Инъекция `renderService` подготовлена в исходниках фреймворка, чтобы упростить её подключение. Тоже самое касается других инъекций. Для отдельного объявления инъекции используются вспомогательные функции `injectClass()`, `injectFactory()` или `injectValue()` - они нужны только для удобной типизации свойств инъекции.

```ts
const renderService = injectClass({  
  token: RENDER_SERVICE,  
  constructor: RenderService, // Класс сервиса (конструктор) 
  depends: {  
    env: ENV,  
    container: CONTAINER,  
    logger: LOG_SERVICE,  
    config: optionalToken(RENDER_CFG),
    dump: optionalToken(DUMP_SERVICE),    
    children: optionalToken(RENDER_COMPONENT),  
  },  
});
```

Инъекция содержит токен для идентификации (`token`) , перечисление зависимостей (`depends`) и функцию создания объекта (`factory` или `constructor`). В функцию `factory` или в `constructor` класса будут передаваться объекты, чьи токены перечислены в `depends`. 

`RenderService` представляет собой простой класс необременённый архитектурными особенностями DI, а все зависимости ожидаются в первом аргументе конструктора. Первый аргумент конструктора отмечен ключевым словом `protected`, чтобы автоматически превратился в поле класса.

```ts
class RenderService {  
  constructor(protected depends: {
      env: Env;  
      container: Container;  
      logger: LogInterface;
      config?: Patch<RenderConfig>;
      dump?: DumpService;          
      children?: ReactNode;
  }) {
    //...
  }
}
```

У `RenderService` много зависимостей, и для корректной работы все зависимости нужно будет внедрить в контейнер. Некоторые зависимости опциональные. Например, можно не внедрять настройки, тогда будут применены настройки по умолчанию. Опциональность зависимости учитывается в классе `RenderService`, а через опциональный токен `optionalToken(RENDER_CFG)` в инъекции об этом сообщается контейнеру.

Контейнер наполняется всеми инъекциями в главном файле `src/index.tsx`. Но инъекция не выполняется сразу при добавлении в контейнер. Исполнение инъекции происходит только при выборке объекта из контейнера по соответствующему токену методом `async get(token)`. Контейнер найдёт по токену инъекцию и, если она ещё не выполнялась, то подготовит все зависимости (выберет их тем же методом `get`), выполнит функцию или конструктор инъекции и вернет результат. Если инъекция уже исполнялась, то будет возвращен ранее полученный результат. Таким образом, выбираемые объекты будут создаваться в единственном экземпляре при первом обращении к ним.

В том же файле `src/index.tsx` после создания и наполнения контейнера нужно запустить основную логику приложения. Из контейнера выбирается сервис рендера и запускается его работа. Сервис рендера оказывается инициатором исполнения всего приложения, поэтому его явно выбираем из контейнера. В свою очередь уже контейнером будут созданы другие объекты (сервис логирования и дампа, react элемент для рендера и другие объекты), чтобы передать их в конструктор сервиса рендера. По ходу выполнения программы из контейнера будут браться и другие объекты.

Для выборки объекта из контейнера нужно указать только токен. Не нужно заботиться о дополнительных параметрах и инициализациях объекта. Просто берем объект из контейнера и используем его.

```ts 
const render = await solutions.get(RENDER_SERVICE);  // выбор сервиса из контейрера solutions
render.start();
```

Сервис рендера выбирается по токену `RENDER_SERVICE`, далее вызывается метод `start()` для запуска рендера в браузере. В метод ничего не передаётся для рендера, хотя можно было бы ожидать передачи react элемента. Дело в том, что корневой react элемент часто оборачивается провайдерами для установки в контекст роутера, хранилища и прочего, что по сути является зависимостью для react элемента. А для управления зависимостями имеется DI контейнер. Поэтому корневой react элемент определяется инъекцией в контейнер и автоматически получает все необходимые зависимости. 

```tsx
.set({  
  token: RENDER_COMPONENT,  
  depends: { router: ROUTER_SERVICE },  
  factory: ({ router }) => (  
    <RouterProvider router={router}>  
      <App />    
    </RouterProvider>
  ),  
})
```

Всё что нужно элементу указывается в `depends`, и будет передано в функцию `factory`. Функция `factory` вернёт подготовленный react элемент. Сервис рендера получит react элемент для рендера по токену `RENDER_COMPONENT` так как у сервиса рендера есть зависимость `children` с таким же токеном.
#### _Итог_

*Внедрение зависимостей* (DI) необходимо для слабой связанности между различными частями приложения и для легкой адаптации приложения под разные условия. Внедрение зависимостей обеспечивает *инверсию управления*, когда программный объект самостоятельно не импортирует и не выбирает себе зависимые объекты, а получает их от инициатора действия. Это касается даже внешних библиотек - вместо того чтобы их импортировать, возможно, правильней будет получать их от DI, абстрагируясь от конкретной реализации.

За счёт слабой связанности программные объекты (решения) можно разрабатывать независимо друг от друга в разных репозиториях разными командами и легко переключаться на разные реализации, адаптируя программу под разные условия. Замена инъекции в контейнере приводит к замене используемого объекта во всём приложении. И не нужно будет по всему исходному коду менять логику передачи зависимостей. Например, сервис кэширования в оперативной памяти легко подменить на сопоставимый сервис кэширования в файлы. Или применять разные реализации сервисов на клиенте и на бэкенде. Возможность подмены через DI активно применяется для функционального тестирования с использованием моковых версий сервисов, например, чтобы не выполнять реальные запросы к АПИ в автоматических тестах. 

← [Команды запуска SPA и SSR](npm_commands_for_start_spa_ssr.md) | [Токен](dependency_management/token.md) →
