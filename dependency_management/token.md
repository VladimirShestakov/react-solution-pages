## Токен

Токен используется для идентификации зависимостей и мог бы быть уникальной строкой или числом. Но кроме идентификации нужен контроль типов, чтобы в инъекциии можно было указать идентификатор только на сопоставимый тип объекта, чтобы гарантировать корректность самой инъекции. Поэтому к уникальному значению привязывается тип зависимости. Связка идентификатора с полезной нагрузкой (типом) называется токеном. Для создания токена используется утилита:

```ts
function newToken<Type>(name: string): Token<Type>
```

Необходимо обязательно указать связываемый тип данных и уникальную строку в качестве названия токена. Для обеспечения уникальности строки предлагается использовать формат URI, например `"my-project/my-service"`. Новые токены желательно создавать в отдельных файлах, чтобы можно было импортировать их отдельно от реализации решения.

```ts
// Токен на тип MyService (класс или интерфейс сервиса)
export const MY = newToken<MyService>('my-project/my-service')
// Токен на тип MyServiceConfig (настройки сервиса)
export const MY_CONFIG = newToken<MyServiceConfig>('my-project/my-service/config')
```

Константа `MY` будет объектом с типом `Token<MyService>`. Токен - это не строка, а объект, что позволяет в токене хранить дополнительную полезную информацию, в частности атрибут опциональности.  
#### _Опциональный токен_

Опциональный токен создаётся через декорирование обычного токена утилитой:

```ts
function optionalToken<Type>(token: Token<Type>): TokenDecorator<Type | undefined>
```

Будет создан новый токен, внутри которого будет ссылка на оригинальный токен. Уникальное значение токена будет браться из оригинального токена, но новый токен-декоратор будет подставлять свой предопределённый атрибут опциональности, при этом оригинальный токен не меняется. Заранее создавать опциональные токены не нужно, достаточно декорировать оригинальные токены на месте применения. 

```ts
const MY_OPTIONAL = optionalToken(MY) // :TokenDecorator<MyService | undefined>

console.log(MY_OPTIONAL.is('optional')) // true
console.log(MY_OPTIONAL.key === MY.key) // true
```

Опциональный токен `MY_OPTIONAL` связан с типом `MyService | undefined` и может применяться для указания опциональных зависимостей. Если зависимость опциональная, то подойдет и оригинальный токен, но если в контейнере не будет соответствующей инъекции, то контейнер выкинет исключение, так как оригинальный токен не допускает отсутствия значения. С опциональным токеном ошибок не будет и в зависимость подставится `undefined`. За счёт строгой типизации опциональный токен не получится ошибочно подставить под обязательную зависимость. 
#### _Итог_

Токены создаются под новые решения для идентификации их программного интерфейса (типа), чтобы решения можно было внедрить в DI контейнер и использовать как зависимость в других решениях. Токены также создаются под составные части новых решений, если предполагается получать их как зависимость. Например, токен создаётся на настройки сервиса.

Новый токен не нужно создавать, если планируется реализация аналога некого решения и в аналоге полностью реализуется программный интерфейс оригинального решения без добавления новых методов. Решение-аналог будет внедряться в контейнер по токену оригинального решения.

Так как токены импортируются напрямую в других решениях, то их необходимо описывать в отдельных файлах, отдельно от исходников самого решения. Иначе в сборку решения-аналога попадет исходник оригинального решения, что бессмысленно раздует сборку. 

Токены связаны с типом решения и это позволяется выводить типы по месту применения токена. Например, контейнер заранее не знает, какие инъекции в него будут добавлены, у контейнера нет агрегированного типа про все инъекции. Только за счет самого токена метод get будет выводить тип возвращаемого решения. Токеном обеспечивается слабая связанность в системе типов.

← [Внедрение зависимостей ](dependency_management/dependency_injection.md) | [Инъекция](dependency_management/injection.md) →
