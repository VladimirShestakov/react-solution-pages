# Токен

Токен используется для идентификации зависимостей и мог бы быть уникальной строкой или числом. Но кроме идентификации нужен контроль типов, чтобы в регистрации можно было указать идентификатор только на сопоставимый тип объекта, чтобы гарантировать корректность самой регистрации. Поэтому к уникальному значению привязывается тип зависимости. Связка идентификатора с полезной нагрузкой (типом) называется токеном. Для создания токена используется утилита:

```ts
function newToken<Type>(name: string): Token<Type>
```

Необходимо обязательно указать связываемый тип данных и уникальную строку в качестве названия токена. Для обеспечения уникальности строки предлагается использовать формат URI, например `"my-project/my-service"`. Новые токены желательно создавать в отдельных файлах, чтобы можно было импортировать их отдельно от реализации решения.

```ts
// Токен на тип MyService (класс или интерфейс сервиса)
export const MY = newToken<MyService>('my-project/my-service')
// Токен на тип MyServiceConfig (настройки сервиса)
export const MY_CONFIG = newToken<MyServiceConfig>('my-project/my-service/config')
```

Константа `MY` будет объектом с типом `Token<MyService>`. Токен — это не строка, а объект, что позволяет в токене хранить дополнительную полезную информацию, в частности атрибут опциональности.  
## _Опциональный токен_ `optionalToken()`

Опциональный токен создаётся через декорирование обычного токена утилитой:

```ts
function optionalToken<Type>(token: Token<Type>): TokenDecorator<Type | undefined>
```

Утилита `optionalToken` принимает оригинальный токен и возвращает новый токен, внутри которого будет ссылка на оригинальный токен. Новый токен реализует паттерн проектирования «декоратор». Уникальное значение нового токена будет браться из оригинального токена, но новый токен будет подставлять свой предопределённый атрибут опциональности. Оригинальный токен не меняется и не знает, что на него ссылается другой токен. Заранее создавать опциональный токен не нужно, достаточно декорировать оригинальный токен на месте применения. 

```ts
const MY_OPTIONAL = optionalToken(MY) // :TokenDecorator<MyService | undefined>

console.log(MY_OPTIONAL.is('optional')) // true
console.log(MY_OPTIONAL.key === MY.key) // true
```

Опциональный токен `MY_OPTIONAL` связан с типом `MyService | undefined` и может применяться для указания опциональных зависимостей. Если зависимость опциональная, то подойдет и оригинальный токен, но если в контейнере не будет соответствующей регистрации, то контейнер выкинет исключение, так как оригинальный токен не допускает отсутствия значения. С опциональным токеном ошибок не будет и в зависимость подставится `undefined`. За счёт строгой типизации опциональный токен не получится ошибочно подставить под обязательную зависимость. 
## _Итог_

Токены создаются под новые решения для идентификации их программного интерфейса (типа), чтобы решения можно было внедрить в DI контейнер и использовать как зависимость в других решениях. Токены также создаются под составные части новых решений, если предполагается получать их как зависимость. Например, токен создаётся на настройки сервиса.

Новый токен не нужно создавать, если планируется реализация аналога некого решения и в аналоге полностью реализуется программный интерфейс оригинального программного решения без добавления новых методов. Решение-аналог будет регистрироваться в контейнере по токену оригинального решения.

Так как токены импортируются напрямую в других программных решениях, то их необходимо описывать в отдельных файлах, отдельно от исходников самого решения. Иначе в сборку решения-аналога попадет исходник оригинального решения, что бессмысленно раздует сборку. 

Токены связаны с типом решения и это позволяется выводить типы по месту применения токена. Например, контейнер заранее не знает, какие регистрации в него будут добавлены, у контейнера нет агрегированного типа про все регистрации. Только за счет самого токена метод get будет выводить тип возвращаемого решения. Токеном обеспечивается слабая связанность в системе типов.

← [Внедрение зависимостей ](dependency_management/dependency_injection.md) | [Регистрация](registration.md) →
